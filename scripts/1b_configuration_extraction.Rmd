---
title: "Extract landscape metrics"
author: "Aidan Brushett"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: default
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE)
```


```{r}
library(tidyverse)
library(terra)
library(sf)
library(landscapemetrics)
```

```{r}
configuration <- rast("./rasters/Merged_HFI_Landcover_Simplified.tif")

configuration_full <- rast("./rasters/Merged_HFI_Landcover.tif")

plot(configuration)

#plot(landscape)
#check_landscape(configuration)
```

```{r}
sites <- st_read("./maps/OSM_mapping.gdb", layer = "all_arrays_locations_covariates") %>%
  
  filter(str_detect(array, "LU"))

plot(sites[1])
```

```{r Extract landscapemetrics - raster w/ SIMPLIFIED landcover classes}
# Create a buffer of 5500m around the site
# Convert the buffer to a SpatVector for use with terra
# Extract the raster values within the buffer

config_data <- list()

for(i in 1:length(sites)){
  
  site <- sites[i,]
  
  config_local <- crop(configuration_full,
                     vect(st_buffer(site, 
                                    dist = 5500)))
  
  plot(config_local)
  
  config_data_lu <- list()

  for (size in seq(250, 5000, by = 250)) {
    
    cat("\r Extracting site", i, "of", length(sites), "(", site$site, "//", size, "m buffer )")
    
    output <- sample_lsm(config_local, y = site, 
             # Create the buffer and sizes of buffer (we made a loop for size above)
             shape = "circle", size = size, 
             # Calculations we would like to extract
             what = c("lsm_c_np", # NUMBER OF PATCHES
                      #"lsm_c_pland", # PERCENT LAND (composition)
                      "lsm_c_pd", # PATCH DENSITY number of patches per 100 Ha
                      "lsm_c_area_mn", # MEAN OF PATCH AREA (mean area of all patches -- e.g. many small patches or few large ones?)
                      "lsm_c_lpi", # LARGEST PATCH INDEX (percent of landscape covered by the largest patch of each class -- measure of dominance)
                      "lsm_c_tca", # TOTAL CORE AREA (sum of core areas of all patches)
                      "lsm_c_core_mn", # MEAN CORE AREA (of core areas of all patches)
                      "lsm_c_split", # Splitting index (number of patches if all patches were divided into equal-sized patches -- i.e. the effective number of patches. Accounts for patch size distribution)
                      "lsm_l_split", # Landscape scale splitting index
                      "lsm_c_ed", # EDGE DENSITY (EDGE LENGTH IN METERS)
                      "lsm_c_cohesion" # COHESION (characterizes connectedness of patches -- aggregated or isolated?)
                      ), 
             # Directions set to queen's case (8)
             directions = 8,
             # Number of pixels considered to be edge
             edge_depth = 4, # a 20 meter edge depth, in line with literature
             # If cells ONLY neighbour the landscape boundary, count as core
             consider_boundary = TRUE, 
             # Returns NA for classes not present in sample plots
             all_classes = TRUE,
             # Matches up the buffer with the site, very important
             plot_id = site$site,
             # Print warning messages
             verbose = TRUE, 
             # Print progress report
             progress = FALSE,
             # Do not return the clipped raster
             return_raster = FALSE)
    
    config_data_lu[[as.character(size)]] <- output %>%
  
        mutate(buffer = size,
             value = replace_na(value, 0),
             class = as.character(class) %>% replace_na(., "LANDSCAPE"),
             class = case_when(class == "0" ~ "WATER",
                               class == "1" ~ "NATURAL",
                               class == "2" ~ "ANTHROPOGENIC",
                               TRUE ~ class)
                               ) %>%
      
      select(-id, -layer)
    
    gc()
    
  }
  
  config_data[[site$site]] <- bind_rows(config_data_lu)
  
}

save(config_data, file = "./data/raw/configuration_metrics.RData")
```

```{r}
load("./data/raw/configuration_metrics.RData")

config_data <- bind_rows(config_data)

write_csv(config_data, "./data/processed/OSM_2021_2022_2023_configuration_metrics_simplified.csv")
```



