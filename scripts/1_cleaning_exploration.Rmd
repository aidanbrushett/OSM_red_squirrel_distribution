---
title: "1_data_cleaning"
output: html_document
date: "2025-03-19"

---

# Load libraries
```{r}
library(PerformanceAnalytics)
library(tidyverse)
library(dplyr)
```


## General cleaning/ checking and combining data 

# 1. Import the data and clean it up a bit

```{r}
# species presence absence data
dets <- read_csv("data/raw/all_arrays_proportional_presence_weekly_clean.csv")

# we just need red squirrel detections 
dets <- dets %>%
  dplyr::select(array, 
         site, 
         red_squirrel, 
         absent_red_squirrel)

# remove CL and WF arrays
dets <- dets %>%
  filter(array != "CL") %>%
  filter(array != "WF")
  

str(dets)
summary(dets)

dets$array <- as.factor(dets$array)
length(unique(dets$site))

# there should be 10 arrays 
levels(dets$array)

# covariate data 
covs <- read_csv("data/raw/OSM_composition_grouped_2021_2022_2023.csv")

str(covs)
summary(covs)

length(unique(covs$site))

# all reading in ok

```


```{r select the covariates we want}
covs <- covs %>%
  dplyr::select(site, buff_dist, harvest, pipeline, roads, seismic_lines, 
         seismic_lines_3D, transmission_lines, wells, 
         lc_grassland, lc_coniferous, 
         lc_broadleaf, lc_mixed, lc_shrub, osm_industrial)


# group some variables 
covs$seismic <- covs$seismic_lines + covs$seismic_lines_3D
covs$linear <- covs$transmission_lines + covs$pipeline


# drop the columns we don't need
covs <- covs %>%
  dplyr::select(-pipeline, -transmission_lines, -seismic_lines, -seismic_lines_3D)

```

```{r fix the leading zeros and stuff}

# need to drop the leading zeros in the site numbers so it can be combined with week data
covs <- covs %>%
    mutate(
              site = gsub("-", "_", site) %>% # First, replace the hyphen with underscore
                gsub("_0+", "_", .) %>% # Then, remove leading zeros after the underscore
                gsub(" ", "", .) %>% # Then, remove any spaces
                gsub("LU0", "LU", .)) # Remove leading zeros from LU names for consistency
```


```{r long and wide dataframes}

data_long <- dets %>%
  left_join(covs, by = "site")

length(unique(data_long$buff_dist))

#write.csv(data_long, "data/processed/analysis_df.csv")


data_wide <- data_long %>%

  # pivot wider was not collapsing the data very well with the camera and array variables present. 
  # let's remove them first. 
  dplyr::select(site, buff_dist, red_squirrel, absent_red_squirrel, harvest, seismic, 
                roads, linear, wells, 
         lc_grassland, lc_coniferous, 
         lc_broadleaf, lc_mixed, lc_shrub, osm_industrial) %>% 

  # wide data
  pivot_wider(names_from = buff_dist,
              values_from = c(harvest, seismic, roads, linear, wells, 
         lc_grassland, lc_coniferous, 
         lc_broadleaf, lc_mixed, lc_shrub, osm_industrial)) %>%
  
  # let's re-add the array and camera columns that we previously lost.
  # this code is redundant but seems to help `pivot_wider` do its job. 
  separate_wider_delim(site,
                       delim = '_',
                       names = c('array',
                                 'site'),
                       cols_remove = FALSE) %>%
  
  # specify format of new columns
  mutate(array = as.factor(array),
         site = as.factor(site))


str(data_wide)
```

We now have a 'long format' dataframe that we will use for step AIC

Now lets create a list with all the covariates for each scale. This code was taken from Marissa's OSM analysis. 

```{r subset data}

buffer_frames <- list()

for (i in unique(covs$buff_dist)){
  
  print(i)
  
  # Subset data based on radius
  df <- covs %>%
    filter(buff_dist == i)
  
  # list of dataframes
  buffer_frames <- c(buffer_frames, list(df))
}

# name list objects so we can extract names for plotting 

buffer_frames <- buffer_frames %>% 
  
  # absurdly long way to do this but for sake of time fuck it
  purrr::set_names('250 meter buffer',
                   '500 meter buffer',
                   '750 meter buffer',
                   '1000 meter buffer',
                   '1250 meter buffer',
                   '1500 meter buffer',
                   '1750 meter buffer',
                   '2000 meter buffer',
                   '2250 meter buffer',
                   '2500 meter buffer',
                   '2750 meter buffer',
                   '3000 meter buffer',
                   '3250 meter buffer',
                   '3500 meter buffer',
                   '3750 meter buffer',
                   '4000 meter buffer',
                   '4250 meter buffer',
                   '4500 meter buffer',
                   '4750 meter buffer',
                   '5000 meter buffer')

```

Join this to the response

```{r response metric}

squirrel <- buffer_frames %>% 
  
  purrr::map(
    ~.x %>% 
      
      left_join(dets,
                by = 'site') %>%
      
      dplyr::select(array, everything()))

```

Model each variable at each scale. 

```{r model for each variable at every scale }

squirrel_mods <- squirrel %>%
  
  purrr::map(
    ~ {
      # get the buffer values (for model names)
      buff_dist_value <- unique(.x$buff_dist)

      # Pass squirrel to df and exclude site and buff_dist
      df <- .x %>%
        select(-site, -buff_dist)

      # Treat array as a factor
      df$array <- as.factor(df$array)

      # these column are for the predictors 
      numeric_columns <- df %>% 
        
        # they should already be numeric
        select(where(is.numeric)) %>%
          
        # make sure the response is not included!
        select(- red_squirrel, - absent_red_squirrel) %>%
        names()

      # List to store models
      model_list <- purrr::map(numeric_columns, ~ {
        
        # Create model formula
        formula <- as.formula(paste("cbind(red_squirrel, absent_red_squirrel) ~", 
                                    .x, "+ (1 | array)"))

        # model name using the variable and the buffer size 
        model_name <- paste0(.x, "_", buff_dist_value)

        # Run the glmmTMB model for each numeric variable
        model <- glmmTMB::glmmTMB(
          formula = formula,
          data = df,
          family = 'binomial'
        )
        
        # Add the model name as a list element 
        model_with_name <- list(model = model, model_name = model_name)

        return(model_with_name) 
      })
      
      return(model_list) 
    })


```


```{r model names? }

# Extract model names from squirrel_mods
model_names <- purrr::map(squirrel_mods, ~ purrr::map(.x, "model_name"))

# Flatten the list to get a simple vector of names
model_names <- unlist(model_names)


```


``` {r look at the model results for scale}

model_info_df <- purrr::map_dfr(squirrel_mods, ~ {
  
  purrr::map_dfr(.x, ~ {
    model <- .x$model
    model_name <- .x$model_name
    
    # get the AIC values 
    model_summary <- data.frame(
      model_name = model_name,
      AIC = AIC(model),
      stringsAsFactors = FALSE
    )
    
    return(model_summary)
  })  
})


# remove lc because that is causing issues
model_info_df <- model_info_df %>%
  mutate(model_name = str_remove(model_name, "^lc_"))


# new dataframe for each variable models

# Create dynamic data frames for each unique prefix in model_name
unique_prefixes <- unique(str_extract(model_info_df$model_name, "^[^_]+"))

# Create a list to store data frames
model_dataframes <- list()

# Loop over each prefix and create a corresponding data frame
for (prefix in unique_prefixes) {
  model_dataframes[[prefix]] <- model_info_df %>%
    filter(str_starts(model_name, prefix))
}


# separate dataframs

# Loop through the list and create separate data frames
for (name in names(model_dataframes)) {
  assign(name, model_dataframes[[name]])
}


# all in one

# Extract the row with the highest AIC (or any other column you prefer)
top_model <- model_dataframes %>%
  map(~ .x[which.min(.x$AIC), ]) %>%  # row with the highest AIC from each data frame
  bind_rows()  # rows into a single data frame


```
Note about scales

No clear top model: 
- conifer (scale all over the place)
- linear (some similar between 1000 - 2250m) 
- shrub (just under 2 units apart, between 1 and 4000)
- veg edges (top ~ 4000 m)
- wells (3 top ~ 4000 m)

```{r correlation at all buffer sizes}

squirrel %>% 
  
  purrr::map(
    ~.x %>% 
      
      # select only columns with covarites not other info
      select(harvest:osm_industrial) %>% 
      
      # use chart.correlation 
      chart.Correlation(.,
                      histogram = TRUE, 
                       method = "pearson")
  )
  
```

# 2. Explore the independent variables 
```{r}
# histograms of everything!

squirrel_cor %>% 
  
  # use imap which will retain both the data (x) and the variable names (y)
  imap(~.x %>% 
        
         # use the hist function on the data from previous pipe
        hist(.,
             
             # set the main title to y (each variable)
             main = .y))


# harvest has tons of zeros, same with transmission lines

```

# 3. Distribution of response variable 

```{r}
hist(squirrel$red_squirrel)
hist(squirrel$absent_red_squirrel)
```


Format the wide data

```{r wide dataframe for modelling}


