---
title: "1_data_cleaning"
output: html_document
date: "2025-03-19"

---

# Load libraries
```{r}
library(PerformanceAnalytics)
library(tidyverse)
library(MuMIn)
library(dplyr)
```


## General cleaning/ checking and combining data 

# 1. Import the data and clean it up a bit

Aidan created weekly proportional presence absence data 

```{r}
# species presence absence data
#dets <- read_csv("OSM_proportional_detections_merged_2021_2022.csv")

dets <- read_csv("all_arrays_proportional_presence_weekly_clean.csv")

# we just need red squirrel detections 
dets <- dets %>%
  select(array, 
         site, 
         red_squirrel, 
         absent_red_squirrel)

# remove CL and WF arrays
dets <- dets %>%
  filter(array != "CL") %>%
  filter(array != "WF")
  

str(dets)
summary(dets)

dets$array <- as.factor(dets$array)

# there should be 10 arrays 
levels(dets$array)

# covariate data 
covs <- read_csv("OSM_covariates_grouped_2021_2022.csv")

str(covs)
summary(covs)

# all reading in ok

```

2. Fix the array/site ID in the covs dataframe so that we can merge them 
```{r}

# need to drop the leading zeros in the site numbers so it can be combined with week data
covs <- covs %>%
    mutate(
              site = gsub("-", "_", site) %>% # First, replace the hyphen with underscore
                gsub("_0+", "_", .) %>% # Then, remove leading zeros after the underscore
                gsub(" ", "", .) %>% # Then, remove any spaces
                gsub("LU0", "LU", .)) # Remove leading zeros from LU names for consistency
```


```{r select the covariates we want}
covs <- covs %>%
  select(site, buff_dist, harvest, pipeline, roads, seismic_lines, 
         seismic_lines_3D, transmission_lines, veg_edges, wells, 
         lc_grassland, lc_coniferous, 
         lc_broadleaf, lc_mixed, lc_shrub, osm_industrial)


# group some variables 
covs$seismic <- covs$seismic_lines + covs$seismic_lines_3D
covs$linear <- covs$transmission_lines + covs$pipeline


# drop the columns we don't need
covs <- covs %>%
  select(-pipeline, -transmission_lines, -seismic_lines, -seismic_lines_3D)

```

Create a list with all the covariates for each scale. 

```{r subset data}

buffer_frames <- list()

for (i in unique(covs$buff_dist)){
  
  print(i)
  
  # Subset data based on radius
  df <- covs %>%
    filter(buff_dist == i)
  
  # list of dataframes
  buffer_frames <- c(buffer_frames, list(df))
}

# name list objects so we can extract names for plotting 

buffer_frames <- buffer_frames %>% 
  
  # absurdly long way to do this but for sake of time fuck it
  purrr::set_names('250 meter buffer',
                   '500 meter buffer',
                   '750 meter buffer',
                   '1000 meter buffer',
                   '1250 meter buffer',
                   '1500 meter buffer',
                   '1750 meter buffer',
                   '2000 meter buffer',
                   '2250 meter buffer',
                   '2500 meter buffer',
                   '2750 meter buffer',
                   '3000 meter buffer',
                   '3250 meter buffer',
                   '3500 meter buffer',
                   '3750 meter buffer',
                   '4000 meter buffer',
                   '4250 meter buffer',
                   '4500 meter buffer',
                   '4750 meter buffer',
                   '5000 meter buffer')

```

Join this to the response

```{r response metric}

squirrel <- buffer_frames %>% 
  
  purrr::map(
    ~.x %>% 
      
      left_join(dets,
                by = 'site') %>%
      
      select(array, everything()))

```

Model each variable at each scale. 

```{r model for each variable at every scale }

squirrel_mods <- squirrel %>%
  
  purrr::map(
    ~ {
      # get the buffer values (for model names)
      buff_dist_value <- unique(.x$buff_dist)

      # Pass squirrel to df and exclude site and buff_dist
      df <- .x %>%
        select(-site, -buff_dist)

      # Treat array as a factor
      df$array <- as.factor(df$array)

      # these column are for the predictors 
      numeric_columns <- df %>% 
        
        # they should already be numeric
        select(where(is.numeric)) %>%
          
        # make sure the response is not included!
        select(- red_squirrel, - absent_red_squirrel) %>%
        names()

      # List to store models
      model_list <- purrr::map(numeric_columns, ~ {
        
        # Create model formula
        formula <- as.formula(paste("cbind(red_squirrel, absent_red_squirrel) ~", 
                                    .x, "+ (1 | array)"))

        # model name using the variable and the buffer size 
        model_name <- paste0(.x, "_", buff_dist_value)

        # Run the glmmTMB model for each numeric variable
        model <- glmmTMB::glmmTMB(
          formula = formula,
          data = df,
          family = 'binomial'
        )
        
        # Add the model name as a list element 
        model_with_name <- list(model = model, model_name = model_name)

        return(model_with_name) 
      })
      
      return(model_list) 
    })


```


```{r model names? }

# Extract model names from squirrel_mods
model_names <- purrr::map(squirrel_mods, ~ purrr::map(.x, "model_name"))

# Flatten the list to get a simple vector of names
model_names <- unlist(model_names)


```


``` {r look at the model results for scale}

model_info_df <- purrr::map_dfr(squirrel_mods, ~ {
  
  purrr::map_dfr(.x, ~ {
    model <- .x$model
    model_name <- .x$model_name
    
    # Extract the model's AIC, BIC, and logLik
    model_summary <- data.frame(
      model_name = model_name,
      AIC = AIC(model),
      
      logLik = logLik(model),
      stringsAsFactors = FALSE
    )
    
    return(model_summary)
  })  #


# remove lc because that is causing issues
model_info_df <- model_info_df %>%
  mutate(model_name = str_remove(model_name, "^lc_"))


# new dataframe for each variable models

# Create dynamic data frames for each unique prefix in model_name
unique_prefixes <- unique(str_extract(model_info_df$model_name, "^[^_]+"))

# Create a list to store data frames
model_dataframes <- list()

# Loop over each prefix and create a corresponding data frame
for (prefix in unique_prefixes) {
  model_dataframes[[prefix]] <- model_info_df %>%
    filter(str_starts(model_name, prefix))
}


# separate dataframs

# Loop through the list and create separate data frames
for (name in names(model_dataframes)) {
  assign(name, model_dataframes[[name]])
}


# all in one

# Extract the row with the highest AIC (or any other column you prefer)
top_model <- model_dataframes %>%
  map(~ .x[which.min(.x$AIC), ]) %>%  # Extract the row with the highest AIC from each data frame
  bind_rows()  # Combine the rows into a single data frame


```
Note about scales

No clear top model: 
- conifer (scale all over the place)
- linear (some similar between 1000 - 2000m) 
- shrub (just under 2 units, between 1 and 4000)
- veg edges (top ~ 4000 m)
- wells (3 top ~ 4000 m)

```{r correlation at all buffer sizes}

squirrel %>% 
  
  purrr::map(
    ~.x %>% 
      
      # select only columns with covaraites not other info
      
select(harvest:osm_industrial) %>% 
      
      # use chart.correlation 
 chart.Correlation(.,
                      histogram = TRUE, 
                       method = "pearson")
  )
  
```

250m - roads and veg edges 0.71
500m - roads and veg edges 0.71
750m - pipeline + trans 0.63, roads + veg edges 0.73, conifer + broad -0.63
1000m - pipeline + trans 0.70, roads + veg edges 0.74, conifer + broad -0.66
        roads + developed 0.64
1250m - pipeline + trans 0.72, roads + veg edges 0.81, conifer + broad -0.66
        roads + developed 0.72, roads + wells 0.60, veg edges + developed 0.64
1500m - pipeline + trans 0.72, roads + veg edges 0.84, conifer + broad -0.70
        roads + developed 0.75, roads + wells 0.65, veg edges + developed 0.70
1750m - pipeline + trans 0.72, roads + veg edges 0.85, conifer + broad -0.71
        roads + developed 0.78, roads + wells 0.65, veg edges + developed 0.73
2000m - 
2250m -
2500m - 
2750m -
3000m - 


# 2. Explore the independent variables 
```{r}
# histograms of everything!

squirrel_cor %>% 
  
  # use imap which will retain both the data (x) and the variable names (y)
  imap(~.x %>% 
        
         # use the hist function on the data from previous pipe
        hist(.,
             
             # set the main title to y (each variable)
             main = .y))


# harvest has tons of zeros, same with transmission lines

```

# 3. Distribution of response variable 

```{r}
hist(squirrel$red_squirrel)
hist(squirrel$absent_red_squirrel)
```




