---
title: "2_step_selection"
output: html_document
date: "2025-03-25"
---
```{r libraries}
library(MASS)
library(dplyr)
library(glmmTMB)
library(lme4)
```

```{r data for modelling}

# this dataframe is formatted and ready to go
data_long <- read_csv("data/processed/analysis_df_long.csv")

# remove the weird first column

data_long <- data_long[,-1]
```

## Step selection 

For the core, disturbance, and configuration models we will run stepAIC at each spatial scale and find the most parsimonious model at the best scale for each model type. Then, choose the overall best model of all spatial scales based on the lowest AIC


For the 'core' model (natural features), variables are: conifer forest, broadleaf forest, mixed forest, shrub, and grassland.

```{r a manual loop to do step wise AIC for the habitat data}

# vector of predictor variables 
predictors <- c("lc_coniferous", "lc_mixed", "lc_shrub", "lc_grassland")

# empty list to store the results
model_results_core <- list()

# Loop over each unique buffer distance 
buff_dist <- unique(data_long$buff_dist)

for (buffer in buff_dist) {
  
  # Subset the data based on the current buffer distance
  subset_data <- data_long[data_long$buff_dist == buffer, ]
  
  # all possible combinations of predictors (31 different combos for core variables)
  model_combinations <- unlist(lapply(1:length(predictors), 
                                      function(i) combn(predictors, i, 
                                      simplify = FALSE)), recursive = FALSE)
  
  # create an empty list to store the models and their AICs
  models <- list()
  
  # loop through each combination of variables and fit the model
  for (combo in model_combinations) {
    
    # Create the formula for the current combination of predictors
    formula <- as.formula(paste("cbind(red_squirrel, absent_red_squirrel) ~", 
                                paste(combo, collapse = " + "), "+ (1 | array)"))
    
    # fit the model with the current formula
    model <- tryCatch({
      glmmTMB(formula, data = subset_data, family = "binomial")
    }
    )
    
    # store the model and AIC
    if (!is.null(model)) {
      models[[paste(combo, collapse = "_")]] <- AIC(model)
    }
  }
  
  # dataframe with the model names andAICs
  model_aic_df <- data.frame(
    model = names(models),
    AIC = unlist(models)
  )
  
  # Rank the models by AIC
  model_aic_df <- model_aic_df %>% 
    arrange(AIC)
  
  # Store the ranked models in the results list
  model_results_core[[as.character(buffer)]] <- model_aic_df
}

```

took out broadlead because correlated 
```{r actual step selection using the dredge function}

# Empty list to store the final model and its AIC for each buffer distance
aic_results_core <- list()

# Loop over each unique buffer distance
buff_dist <- unique(data_long$buff_dist)

for (buffer in buff_dist) {
  
  # Subset the data based on the current buffer distance
  subset_data <- data_long[data_long$buff_dist == buffer, ]
  
  # Fit the initial model for the current buffer distance
  model_core <- glmer(cbind(red_squirrel, absent_red_squirrel) ~ 
                   scale(lc_coniferous) +
                   scale(lc_mixed) + 
                   scale(lc_shrub) +
                   scale(lc_grassland) +
                   (1|array), 
                 data = subset_data, 
                 family = "binomial", 
                 na.action = na.fail)
  
  # Perform stepwise model selection based on AIC
  stepwise_core <- dredge(model_core, 
                           rank = AIC, 
                           evaluate = TRUE, 
                           trace = TRUE)
  
   # Extract the best model based on AICc (the model with the lowest AICc)
  best_model <- get.models(stepwise_core, 1)[[1]]
  
  # Store the final model and its AIC in the list
  aic_results_core[[as.character(buffer)]] <- list(
    model = best_model,
    aic = AIC(best_model)
  )
}
  
```

This will create a new dataframe for each buffer size 
```{r pull out the buffers}

#  individual dataframes for each buffer
for (buffer in buff_dist) {
  
  # get the ranked AIC dataframe for this buffer
  model_aic_df <- model_results_core[[as.character(buffer)]]
  
  # assign the dataframe to a variable
  assign(paste0("core_", buffer), model_aic_df)
}

```


This will make a dataframe with the top model AIC 
```{r make a new dataframe with all the top models for core}

# Function to find the minimum value in a DataFrame (only for numeric columns)
find_min_value <- function(df) {
  # Ensure we are working only with numeric columns
  numeric_cols <- df[sapply(df, is.numeric)]  # Select only numeric columns
  
  # Check if numeric_cols has any numeric columns before proceeding
  if (length(numeric_cols) > 0) {
    # Flatten the numeric columns into a vector and find the minimum
    numeric_vector <- unlist(numeric_cols)  # Convert to a vector
    return(min(numeric_vector, na.rm = TRUE))  # Ignore NA values
  } else {
    return(NA)  # Return NA if no numeric columns exist
  }
}

# Get all object names in the environment
all <- ls()

# Filter the objects that start with 'core_'
core_dataframes <- all[grepl("^core_", all)]

# Extract the DataFrames using the names and apply the function
min_values_core <- sapply(core_dataframes, function(name) {
  df <- get(name)  # Fetch the DataFrame by name
  find_min_value(df)
})

# Convert the results into a new DataFrame
result_core <- data.frame(DataFrame = core_dataframes,
                        Lowest_Value = min_values_core)



#write.csv(result_core, "data/processed/stepAIC_core.csv")

```

The 750 meter scale is the best for the core model by 18 AIC. 

Best model: lc_coniferous + lc_broadleaf + lc_shrub + lc_grassland



For the 'disturbance' model (anthropogenic features), variables are: seismic lines, linear (transmission and pipelines), roads, harvest blocks, well pads, and industrial features. 

```{r a manual loop to do step wise AIC for the disturbance data}

# predictor variables 
predictors <- c("harvest", "linear", "wells", "roads", "osm_industrial", "seismic")

# empty list to store the results
model_results_dist <- list()

# Loop over each unique buffer distance 
buff_dist <- unique(data_long$buff_dist)

for (buffer in buff_dist) {
  
  # Subset the data based on the current buffer distance
  subset_data <- data_long[data_long$buff_dist == buffer, ]
  
  # all possible combinations of predictors (31 different combos for core variables)
  model_combinations <- unlist(lapply(1:length(predictors), 
                                      function(i) combn(predictors, i, 
                                      simplify = FALSE)), recursive = FALSE)
  
  # create an empty list to store the models and their AICs
  models <- list()
  
  # loop through each combination of variables and fit the model
  for (combo in model_combinations) {
    
    # Create the formula for the current combination of predictors
    formula <- as.formula(paste("cbind(red_squirrel, absent_red_squirrel) ~", 
                                paste(combo, collapse = " + "), "+ (1 | array)"))
    
    # fit the model with the current formula
    model <- tryCatch({
      glmmTMB(formula, data = subset_data, family = "binomial")
    }
    )
    
    # store the model and AIC
    if (!is.null(model)) {
      models[[paste(combo, collapse = "_")]] <- AIC(model)
    }
  }
  
  # dataframe with the model names andAICs
  model_aic_df <- data.frame(
    model = names(models),
    AIC = unlist(models)
  )
  
  # Rank the models by AIC
  model_aic_df <- model_aic_df %>% 
    arrange(AIC)
  
  # Store the ranked models in the results list
  model_results_dist[[as.character(buffer)]] <- model_aic_df
}

```


```{r pull out the buffers}

#  individual dataframes for each buffer
for (buffer in buff_dist) {
  
  # get the ranked AIC dataframe for this buffer
  model_aic_df <- model_results_dist[[as.character(buffer)]]
  
  # assign the dataframe to a variable
  assign(paste0("dist_", buffer), model_aic_df)
}

```

```{r make a new dataframe with all the top models for dist}

# Get all object names in the environment
all <- ls()

# Filter the objects that start with 'core_'
dist_dataframes <- all[grepl("^dist_", all)]

# Function to find the minimum value in a DataFrame (only for numeric columns)
find_min_value <- function(df) {
  # Ensure we are working only with numeric columns
  numeric_cols <- df[sapply(df, is.numeric)]
  return(min(numeric_cols, na.rm = TRUE))  # Ignore NA values
}

# Extract the DataFrames using the names and apply the function
min_values_dist <- sapply(dist_dataframes, function(name) {
  df <- get(name)  # Fetch the DataFrame by name
  find_min_value(df)
})

# Convert the results into a new DataFrame
result_dist <- data.frame(DataFrame = dist_dataframes,
                        Lowest_Value = min_values_dist)

#write.csv(result_dist, "data/processed/stepAIC_dist.csv")

```


The 2000 meter scale is the best for the disturbance model by 5.8 AIC. 

Best model: harvest + linear + wells + roads + seismic (osm_industrial is an uninformative prior)


```{r a manual loop to do step wise AIC for the configuration data}

# predictor variables 
predictors <- c("natural_cohesion", "anthropogenic_cohesion", "natural_tca", "anthropogenic_tca", "natural_ed", "anthropogenic_ed")

# empty list to store the results
model_results_conf <- list()

# Loop over each unique buffer distance 
buff_dist <- unique(data_long$buff_dist)

for (buffer in buff_dist) {
  
  # Subset the data based on the current buffer distance
  subset_data <- data_long[data_long$buff_dist == buffer, ]
  
  # all possible combinations of predictors (31 different combos for core variables)
  model_combinations <- unlist(lapply(1:length(predictors), 
                                      function(i) combn(predictors, i, 
                                      simplify = FALSE)), recursive = FALSE)
  
  # create an empty list to store the models and their AICs
  models <- list()
  
  # loop through each combination of variables and fit the model
  for (combo in model_combinations) {
    
    # Create the formula for the current combination of predictors
    formula <- as.formula(paste("cbind(red_squirrel, absent_red_squirrel) ~", 
                                paste(combo, collapse = " + "), "+ (1 | array)"))
    
    # fit the model with the current formula
    model <- tryCatch({
      glmmTMB(formula, data = subset_data, family = "binomial")
    }
    )
    
    # store the model and AIC
    if (!is.null(model)) {
      models[[paste(combo, collapse = "_")]] <- AIC(model)
    }
  }
  
  # dataframe with the model names andAICs
  model_aic_df <- data.frame(
    model = names(models),
    AIC = unlist(models)
  )
  
  # Rank the models by AIC
  model_aic_df <- model_aic_df %>% 
    arrange(AIC)
  
  # Store the ranked models in the results list
  model_results_conf[[as.character(buffer)]] <- model_aic_df
}
```


```{r pull out the buffers}

#  individual dataframes for each buffer
for (buffer in buff_dist) {
  
  # get the ranked AIC dataframe for this buffer
  model_aic_df <- model_results_conf[[as.character(buffer)]]
  
  # assign the dataframe to a variable
  assign(paste0("conf_", buffer), model_aic_df)
}

```

```{r make a new dataframe with all the top models for config}

# Get all object names in the environment
all <- ls()

# Filter the objects that start with 'core_'
conf_dataframes <- all[grepl("^conf_", all)]

# Function to find the minimum value in a DataFrame (only for numeric columns)
find_min_value <- function(df) {
  # Ensure we are working only with numeric columns
  numeric_cols <- df[sapply(df, is.numeric)]
  return(min(numeric_cols, na.rm = TRUE))  # Ignore NA values
}

# Extract the DataFrames using the names and apply the function
min_values_conf <- sapply(conf_dataframes, function(name) {
  df <- get(name)  # Fetch the DataFrame by name
  find_min_value(df)
})

# Convert the results into a new DataFrame
result_conf <- data.frame(DataFrame = conf_dataframes,
                        Lowest_Value = min_values_conf)

write.csv(result_conf, "data/processed/stepAIC_conf.csv")

```
