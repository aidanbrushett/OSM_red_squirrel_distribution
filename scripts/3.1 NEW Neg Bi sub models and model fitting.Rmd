---
title: "Submodels and final models"
author: "Emerald Arthurs and Aidan Brushett"
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: default
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      paged.print=TRUE)
```

# 0. Before you begin

Emerald Arthurs
M.Sc. Student
University of Victoria    
School of Environmental Studies     
Email: [emeraldarthurs@uvic.ca](emeraldarthurs@uvic.ca)

Aidan Brushett
M.Sc. Student
University of Victoria    
School of Environmental Studies     
Email: [aidanbrushett@uvic.ca](aidanbrushett@uvic.ca)

***

# 1. Setup

```{r libraries, message=FALSE, warning=FALSE}
rm(list = ls())
#library(MASS)
library(glmmTMB)
#library(lme4)
library(tidyverse)
library(MuMIn)
library(rphylopic)
library(corrr)
library(performance)
library(PerformanceAnalytics)

#`%nin%` <- Negate(`%in%`)
```
# 2. Import data

We will also apply standardized z-scaling to the data. This is done *per buffer* since technically they are different datasets. 

```{r data for modelling}
#data <- read_csv("./data/processed/OSM_proportional_weekly_presence_with_covariates_2021_2022_2023.csv")
# OR 
#data <- read_csv("./data/processed/OSM_proportional_monthly_presence_with_covariates_2021_2022_2023.csv")
# OR
#data <- read_csv("./data/processed/OSM_monthly_detections_with_covariates_2021_2022_2023.csv")

data <- read_csv("./data/processed/monthly_all_covs.csv")
  
  
# Apply standardized z-scaling to all predictors:
data_scaled <- data %>%
  
  group_by(buffer_dist) %>%
  
  mutate(across(harvest:last_col(), ~ as.numeric(scale(.)))) %>%
  
  ungroup(.)

# The mean will not be perfectly 0 since we grouped the variables by buffer distance to perform the scaling. 
summary(data_scaled)
```


```{r}
# Histograms for each buffer size
cor_data <- purrr::map(seq(250, 5000, by = 250), 
                        ~ data %>% 
                          
                          filter(buffer_dist == .x) %>%
                        
      dplyr::select(harvest:LC_MIXEDWOOD) %>% 
      
      corrr::correlate(., use = "pairwise.complete.obs", 
                                           method = "spearman", 
                                           diagonal = NA, 
                                           quiet = TRUE))
  
#writexl::write_xlsx(cor_data, "./data/processed/OSM_all_covariates_correlation_new.xlsx")
  
```
 pice mar (black spruce) and popu tre (trembling) are highly correlated at 250 m 
 removed popu tre 
 broadleaf and pice mar

# 3. SUB MODELS 

## 3.1. 'NATURAL' sub-model 1: tree percentages

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
natural_trees <- list()

for (buffer in buff_dist) {
  data_subset <- data_scaled[data_scaled$buffer_dist == buffer, ]
  model_trees <- glmmTMB(squirrel ~ 
                          PINU.BAN_PCT_OF_TREED +
                          PICE.MAR_PCT_OF_TREED +
                          PICE.GLA_PCT_OF_TREED +
                          LARI.LAR_PCT_OF_TREED + 
                          (1|array/site), 
                        data = data_subset, 
                        family = nbinom2, 
                        na.action = na.fail)

  natural_trees[[as.character(buffer)]] <- model_trees
}

# Perform model selection using model.sel
natural_tree_model <- MuMIn::model.sel(natural_trees)

## print in console because the dataframe is not working?????????????

# Add buffer and submodel columns to the selection results
natural_tree_model <- natural_tree_model %>%
  mutate(buffer = as.numeric(rownames(natural_tree_model)),
         submodel = "NATURAL_trees")
```

'NATURAL' sub-model 2: cover types

add all landcover types to this model
```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
natural_cover <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_cover <- glmmTMB(squirrel ~ 
                           LC_CONIFEROUS +
                           LC_BROADLEAF + 
                           LC_MIXEDWOOD +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_cover)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "NATURAL_cover")
```

'NATURAL' sub-model 3: harvest years - under or above 15

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
natural_harvest15 <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_harvest15 <- glmmTMB(squirrel ~ 
                           harvest_15_orunder +
                           harvest_15_above +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_harvest15)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "NATURAL_harvest15")
```

'NATURAL' sub-model 4: trees and cover

remove broadleaf because it is correlated with a tree type

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
natural_trees_cover <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_trees_cover <- glmmTMB(squirrel ~
                           PINU.BAN_PCT_OF_TREED +
                           #POPU.TRE_PCT_OF_TREED + 
                           PICE.MAR_PCT_OF_TREED +
                           PICE.GLA_PCT_OF_TREED +
                           LARI.LAR_PCT_OF_TREED +     
                           LC_CONIFEROUS +
                           LC_BROADLEAF + 
                           LC_MIXEDWOOD +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_trees_cover)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "NATURAL_trees_cover")
```

'NATURAL' sub-model 5: trees and harvest

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
natural_trees_harvest <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_trees_harvest <- glmmTMB(squirrel ~
                           PINU.BAN_PCT_OF_TREED +
                           #POPU.TRE_PCT_OF_TREED + 
                           PICE.MAR_PCT_OF_TREED +
                           PICE.GLA_PCT_OF_TREED +
                           LARI.LAR_PCT_OF_TREED +     
                           harvest_15_orunder +
                           harvest_15_above +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_trees_harvest)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "NATURAL_trees_harvest")
```

'NATURAL' sub-model 6: cover and harvest

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
natural_cover_harvest <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_cover_harvest <- glmmTMB(squirrel ~
                           harvest_15_orunder +
                           harvest_15_above +   
                           LC_CONIFEROUS +
                           LC_BROADLEAF + 
                           LC_MIXEDWOOD +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_cover_harvest)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "NATURAL_cover_harvest")
```

'NATURAL' sub-model 7: cover, harvest, and trees

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
natural_cover_harvest_trees <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_cover_harvest_trees <- glmmTMB(squirrel ~
                           harvest_15_orunder +
                           harvest_15_above +   
                           LC_CONIFEROUS +
                           LC_BROADLEAF + 
                           LC_MIXEDWOOD +
                           PINU.BAN_PCT_OF_TREED +
                           #POPU.TRE_PCT_OF_TREED + 
                           PICE.MAR_PCT_OF_TREED +
                           PICE.GLA_PCT_OF_TREED +
                           LARI.LAR_PCT_OF_TREED + 
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_cover_harvest_trees)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "NATURAL_cover_harvest_trees")
```


## 3.2. 'COMP' sub-models

'COMP' sub-model 1: seismic, pipelines, abandoned wells 

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
comp_seis_pipe_wells <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_seis_pipe_wells <- glmmTMB(squirrel ~
                           seismic +
                           pipe_trans +   
                           wells_aband +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_seis_pipe_wells)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "COMP_seis_pipe_wells")
```

'COMP' sub-model 2: harvest

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
comp_harvest <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_harvest <- glmmTMB(squirrel ~
                           harvest +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_harvest)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "COMP_harvest")
```

'COMP' sub-model 3: harvest + model 1

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
comp_harvest_1 <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_harvest_1 <- glmmTMB(squirrel ~
                           harvest +
                           seismic +
                           pipe_trans +
                           wells_aband +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_harvest_1)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "COMP_harvest_1")
```

'COMP' sub-model 4: active 

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
comp_active <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_active <- glmmTMB(squirrel ~
                           roads +
                           osm_industrial +
                           wells_active +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_active)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "COMP_active")
```

'COMP' sub-model 5: harvest + active

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
comp_active_harvest <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_active_harvest <- glmmTMB(squirrel ~
                           roads +
                           osm_industrial +
                           wells_active +
                           harvest +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_active_harvest)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "COMP_active_harvest")
```

'COMP' sub-model 6: global

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
comp_global <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_global <- glmmTMB(squirrel ~
                           roads +
                           osm_industrial +
                           wells_active +
                           harvest +
                           seismic +
                           pipe_trans +
                           wells_aband +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_global)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "COMP_global")

```


## 3.3. 'CONFIG' sub-models

'CONFIG' sub-model 1: edges

```{r natural, message=FALSE, warning=FALSE, paged.print=TRUE}
comp_global <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_global <- glmmTMB(squirrel ~
                          anthropogenic_ed +
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_global)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "COMP_global")

```


## 3.4. Save results

We will save the top predictors and the top spatial scale so that we don't need to re-run the submodels every time. 

```{r}
save(config_results, comp_results, natural_results, 
     comp_predictors, comp_buffer, natural_predictors, 
     natural_buffer, config_predictors, config_buffer, 
     file = "./data/processed/submodel_neg_binomial_dredge_top_predictors_scales.RData")
```

# 4. Scale analysis

Another nice way to visualize our results for the scale analysis is to plot the model weight for the global sub-models at each scale.

Natural sub-model:
```{r}
natural_scale <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_natural <- glmmTMB(squirrel ~ 
                           lc_coniferous +
                           lc_mixed + 
                           lc_shrub +
                           lc_grassland +
                           #(1|site) + 
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_natural)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "NATURAL")
```

Anthro composition submodel:

```{r}
comp_scale <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_comp <- glmmTMB(squirrel ~ 
                           harvest +
                           pipe_trans + 
                           wells + 
                           #roads +
                           osm_industrial + 
                           seismic +
                           #(1|site) + 
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_comp)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "COMPOSITION")
```

Configuration sub-model:
```{r}
config_scale <- purrr::map(seq(250, 5000, by = 250), ~{
  
  # Subset the data based on the current buffer distance
  data_subset <- data_scaled %>%
    
    filter(buffer_dist == .x)
  
  # Fit the initial model for the current buffer distance
  model_config <- glmmTMB(squirrel ~ 
                           anthropogenic_ed +
                           natural_cai_mn + 
                           #forest_tca +
                           #forest_cohesion + 
                           #(1|site) + 
                           (1|array/site), 
                         data = data_subset, 
                         family = nbinom2, 
                         na.action = na.fail)
  
  return(model_config)
  }
  ) %>%
  
  set_names(as.character(seq(250, 5000, by = 250))) %>%
  
  MuMIn::model.sel(.) %>%
  
  mutate(buffer = as.numeric(rownames(.)),
         submodel = "CONFIGURATION")
```

Let's put it all together into a plot:

```{r}
fig_scale <- bind_rows(natural_scale, 
                              comp_scale,
                              config_scale) %>%
  
  ggplot(., aes(x = buffer, y = weight, color = submodel)) + 
  
    geom_line(size = 1) + 
  
    scale_color_manual(values =c("#D24D57",
                                 "#1976D2",
                                 "#388E3C")) + 
                                   
    scale_color_manual(values =c("grey40","grey70","grey10")) +
    #scale_color_viridis_d() + 
  
    theme_bw() + 
    
    scale_y_continuous(limits = c(0, 1), expand = expansion(add = c(0, 0.05))) + 
  
    labs(x = "Buffer radius (m)",
         y = "AIC weight (global model)",
         color = "Sub-model",
         title = "RESQ: sub-model characteristic spatial scales") + 
  
    # Remove all grid lines
    theme(panel.grid = element_blank()) + 
  
    add_phylopic(
      uuid = get_uuid(name = "Sciurus vulgaris"),
      x = 4400,
      y = 0.88, 
      height = 0.24
      )

fig_scale

ggsave("./figures/redsquirrel_neg_binomial_submodel_scale_modelweight.png", width = 7, height = 4, dpi = 500)
```

Clean up a bit:
```{r}
rm(comp_scale, config_scale, natural_scale, data_subset, img, uuid, model_config)
```

# 5. Fit full models

## 5.0. Load the dredge results

If the dredge was run in a previous session, you can re-load the results here to save some time:

```{r}
load("./data/processed/submodel_neg_binomial_dredge_top_predictors_scales.RData")
```

## 5.1. Construct and inspect the final dataset

We will pull out the predictors from the submodels **at the appropriate spatial scales** and merge this into one big dataset for final models.

```{r}
data_final_scaled <- bind_cols(
  
  # response variables
  data_scaled %>%
    select(1:squirrel) %>%
    distinct(),
  
  # natural data
  data_scaled %>% 
    filter(buffer_dist == natural_buffer) %>%
    select(natural_predictors) %>%
    mutate(NATURAL_buffer = natural_buffer), # won't use this column, just keeping track of the scale somehow
  
  # composition data
  data_scaled %>% 
    filter(buffer_dist == comp_buffer) %>%
    select(comp_predictors, harvest) %>%
    mutate(COMP_buffer = comp_buffer), # won't use this column, just keeping track of the scale somehow
  
  # configuration data
  data_scaled %>% 
    filter(buffer_dist == config_buffer) %>%
    select(config_predictors) %>%
    mutate(CONFIG_buffer = config_buffer) # won't use this column, just keeping track of the scale somehow
  ) %>%
  
  relocate(contains("buffer"), .after=("squirrel"))

summary(data_final_scaled)
```

Let's look at the correlation among this final set of candidate variables at their respective spatial scales:

```{r}
data_final_corr <- data_final_scaled %>%
  
  select(9:ncol(.)) %>%
  
  corrr::correlate(., use = "pairwise.complete.obs", 
                                           method = "spearman", 
                                           diagonal = NA, 
                                           quiet = TRUE) %>%
  as_tibble() %>%
                          
  mutate(across(everything(), ~ if_else(row_number() >= min(which(is.na(.))), NA, .))) %>%

  select(rev(names(.))) %>% 

  relocate(term) %>%
  
  pivot_longer(cols = -term, names_to = "var2", values_to = "corr") %>%
  
  rename(var1 = term) %>%
  
  arrange(desc(abs(corr))) %>%
  
  drop_na(.)

head(data_final_corr, 15)
```

There are a few correlations to be concerned about. The main culprit is `veg_anthro_edge` and `seismic`. Removing one or both of these from our models will resolve all the correlations that are above 0.50. 

## 5.2. Fit the models

Now let's fit our models and compete the combination of submodels against each other according to our ecological hypotheses:

```{r}
# Null model
m_null <- glmmTMB::glmmTMB(squirrel ~ 1 +
                             
                     (1|array/site), 
                     data = data_final_scaled, 
                     family = nbinom2)
```

Recall the natural predictors:

```{r}
natural_predictors
```

Let's put these into our model:

```{r}
# Natural model
m_nat <- glmmTMB::glmmTMB(squirrel ~ 
                            
                            # Natural vars
                            lc_coniferous + 
                            #lc_shrub +
                            lc_grassland +
                            lc_mixed + 
                            
                            (1|array/site), 
                            data = data_final_scaled, 
                            family = nbinom2)
```


Recall the anthropogenic composition predictors:

```{r}
comp_predictors
```

Let's put these into our model. Roads and well sites are quite correlated at this scale so we will remove `roads` from the models. There was also weak separation between models with/without `osm_industrial` in the dredging step so we will take this out too. 

```{r}
# Natural + comp model
m_nat_comp <- glmmTMB::glmmTMB(squirrel ~ 
                                 
                                 # natural vars
                                 lc_coniferous + 
                                 #lc_shrub +
                                 lc_grassland +
                                 lc_mixed + 
                                 
                                 # comp vars
                                 harvest + 
                                 pipe_trans + 
                                 seismic + 
                                 wells + 
                                 #roads + 
                                 
                                 (1|array/site), 
                                 data = data_final_scaled, 
                                 family = nbinom2)
```

Recall the configuration predictors:

```{r}
config_predictors
```

These are absolutely nutso correlated with each other so we will only focus on a couple. We'll look at vegetated and non-vegetated anthropogenic edge density for now. 

```{r}
# Natural + config model
m_nat_config <- glmmTMB::glmmTMB(squirrel ~ 
                                 
                                  # natural vars
                                  lc_coniferous + 
                                  #lc_shrub +
                                  lc_grassland +
                                  lc_mixed + 
                                 
                                  # config vars
                                  anthropogenic_ed + 
                                  #natural_cai_mn + 
                                 
                                 (1|array/site), 
                                 data = data_final_scaled, 
                                 family = nbinom2)
```

Our next model will combine as many of these variables as we can into one model without fucked up correlation. Linear anthropogenic features are particularly problematic so we'll remove them and focus on 'polygonal' ones. 

```{r}
# Natural + comp + config model
m_nat_comp_config <- glmmTMB::glmmTMB(squirrel ~ 
                                 
                                 # natural vars
                                 lc_coniferous + 
                                 #lc_shrub +
                                 lc_grassland +
                                 lc_mixed + 
                                 
                                 # comp vars
                                 harvest + 
                                 pipe_trans + 
                                 #seismic + 
                                 wells + 
                                 
                                 # config vars
                                 anthropogenic_ed + 
                                 #natural_cai_mn + 
                                 
                                 (1|array/site), 
                                 data = data_final_scaled, 
                                 family = nbinom2)
```

We'll also make our final hypotheses here by adding a couple interactions to that model. 

```{r}
# Interaction model 1: do edge effects depend on conifer availability?
m_nat_compXconfig_1 <- glmmTMB::glmmTMB(squirrel ~ 
                                 
                                 # natural vars
                                 lc_coniferous + 
                                 #lc_shrub +
                                 lc_grassland +
                                 lc_mixed + 
                                 
                                 # comp vars
                                 harvest + 
                                 pipe_trans + 
                                 #seismic + 
                                 wells + 
                                 
                                 # config vars
                                 anthropogenic_ed + 
                                 #natural_cai_mn + 
                                   
                                 # interactions of interest
                                 lc_coniferous*anthropogenic_ed + 
                                   
                                 (1|array/site), 
                                 data = data_final_scaled, 
                                 family = nbinom2)

# Interaction model 2: do edge effects depend on harvest amount?
m_nat_compXconfig_2 <- glmmTMB::glmmTMB(squirrel ~ 
                                 
                                 # natural vars
                                 lc_coniferous + 
                                 #lc_shrub +
                                 lc_grassland +
                                 lc_mixed + 
                                 
                                 # comp vars
                                 harvest + 
                                 pipe_trans + 
                                 #seismic + 
                                 wells + 
                                 # config vars
                                 anthropogenic_ed + 
                                 #natural_cai_mn + 
                                   
                                 # interactions of interest
                                 wells*anthropogenic_ed + 
                                   
                                 (1|array/site), 
                                 data = data_final_scaled, 
                                 family = nbinom2)

# Interaction model 3: custom
#m_nat_compXconfig_3 <- glmmTMB::glmmTMB(squirrel ~ 
#                                 
#                                 # natural vars
#                                 lc_coniferous + 
#                                 lc_shrub +
#                                 lc_grassland +
#                                 lc_mixed + 
#                                 
#                                 # comp vars
#                                 harvest + 
#                                 wells + 
#                                 
#                                 # config vars
#                                 nonveg_anthro_ed + 
#                                 forest_cohesion + 
#                                   
#                                 # interactions of interest
#                                 harvest*forest_cohesion + 
#                                   
#                                 (1|array/site), 
#                                 data = data_final_scaled, 
#                                 family = nbinom2)
```
 
## 5.3. Perform model selection

Let's gather all the models into a list and perform model selection:

```{r}
#rm(m_nat_comp_config2)

models <- mget(ls(pattern = "m_"))

models_rank <- MuMIn::model.sel(models) %>%
  
    as.data.frame(.) %>%
    
    select(-`disp((Int))`) %>%
  
    rename_with(~ gsub("cond\\(|disp\\(|\\)|\\(", "", .)) %>%
    
    rename(intercept = `Int`)

models_rank

# Fetch the top model
top_model <- get(ls(pattern = rownames(models_rank[1]))[1])
```

## 5.4. Model inspection and validation

### Check out a general summary: 

```{r}
summary(top_model)
```

### Check dispersion:

```{r}
performance::check_overdispersion(top_model)
```
The model is overdispersed. Variance is much higher than the mean which violates an assumption of the bernoilli distribution. A zero inflated bernoulli (ZIB) might be more appropriate. Re-binning the data into monthly occurrence frequency might also help eliminate a lot of the zeros that are (likely) the cause of this. 

### Check other diagnostics including VIFs. 

```{r}
performance::check_model(top_model)

ggsave("./figures/top_model_neg_binomial_diagnostics.png", height = 12, width = 9)
```

### Variance inflation factors:

```{r}
# vif from the car package
performance::check_collinearity(top_model) %>% 
  
  as.data.frame(.) %>%
  
  # plot with ggplot
  ggplot(aes(x = reorder(Term, VIF), # reorders from smallest VIF to largest (not sure I want like this)
             y = VIF)) +
  
    geom_hline(yintercept = 3, linetype='dashed', col = 'firebrick') + 
  
    geom_errorbar(aes(ymin = VIF_CI_low, ymax = VIF_CI_high), width = 0.1) +  # Error bars
  
    # plot as points
    geom_point(size = 2.5) +
    
    # add labels
    labs(x = '',
         y = 'Variance Inflation Factor (VIF)') +
    
    scale_y_continuous(limits = c(0, 3.2), expand = expansion(add = c(0, 0.3))) + 
    
    # set theme
    theme_bw() + 
  
    theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels by 45 degrees

ggsave("./figures/top_model_neg_binomial_VIF.png", dpi=500, width = 5, height = 3.5)
```


## 5.5. Interpret results

```{r}
summary(top_model)
```

Odds ratio plots for the conditional model:

```{r}
confint(top_model) %>%
  
  as_tibble(rownames = "term") %>%
  
  set_names(c('term', 'lower', 'upper', 'estimate')) %>%
  
  mutate(across(c('lower', 'upper', 'estimate'), exp)) %>%
  
  filter(term %nin% c('(Intercept)', 'Std.Dev.(Intercept)|array')) %>%
  
  ggplot(., aes(x = term)) + 
  
    geom_hline(yintercept = 1, linetype='dashed', col = 'grey20') + 
  
    geom_errorbar(aes(x = term, ymin = lower, ymax = upper), width = 0.1) +  # Error bars
    
    # add labels
    labs(x = '',
         y = 'Odds Ratio (standardized)') +
    
    # plot as bars
    geom_point(aes(y = estimate), size = 2.5) +
  
      # set theme
    theme_bw() + 
  
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +   # Rotate x-axis labels by 45 degrees
  
    add_phylopic(
      uuid = get_uuid(name = "Sciurus vulgaris"),
      x = 8.8,
      y = 1.75, 
      height = 0.3
      )

ggsave("./figures/top_model_neg_binomial_odds_ratios.png", width = 5, height = 3.5)
```

## 5.6. Plot conditional effects for a fixed effect of interest (no interaction)

```{r, eval=TRUE}
ggeffects::ggpredict(top_model, terms = c("lc_coniferous [all]")) %>%
                                                                          
  ggplot(., aes(x = x, y = predicted)) +
  
    geom_line(size = 0.5) +  # Set lines to black
  
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.4, fill = 'dodgerblue4') +
  
    labs(x = "proportion conifer forest", 
         y = "squirrel occurrence frequency") +
      
    scale_x_continuous(expand = c(0, 0)) +  # Remove left blank space
  
    theme_bw() + 
  
    theme(panel.grid = element_blank()) + 
      
    add_phylopic(
      uuid = get_uuid(name = "Sciurus vulgaris"),
      x = -1.2,
      y = 0.4, 
      height = 0.06
      )

ggsave("./figures/top_model_neg_binomial_wells.png", dpi=400, width = 6, height = 4)
```


# And for harvest

```{r, eval=TRUE}
ggeffects::ggpredict(top_model, terms = c("wells [all]")) %>%
                                                                          
  ggplot(., aes(x = x, y = predicted)) +
  
    geom_line(size = 0.5) +  # Set lines to black
  
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.4, fill = 'forestgreen') +
  
    labs(x = "proportion wells", 
         y = "expected count") +
      
    scale_x_continuous(expand = c(0, 0)) +  # Remove left blank space
  
    theme_bw() + 
  
    theme(panel.grid = element_blank()) + 
      
    add_phylopic(
      uuid = get_uuid(name = "Sciurus vulgaris"),
      x = 0.1,
      y = 0.42, 
      height = 0.06
      )

ggsave("./figures/top_model_neg_binom_wells.png", dpi=400, width = 6, height = 4)
```

# And for edge effects

```{r, eval=TRUE}
ggeffects::ggpredict(top_model, terms = c("veg_anthro_ed [all]")) %>%
                                                                          
  ggplot(., aes(x = x, y = predicted)) +
  
    geom_line(size = 0.5) +  # Set lines to black
  
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.4, fill = 'forestgreen') +
  
    labs(x = "edge density", 
         y = "expected count") +
      
    scale_x_continuous(expand = c(0, 0)) +  # Remove left blank space
  
    theme_bw() + 
  
    theme(panel.grid = element_blank()) + 
      
    add_phylopic(
      uuid = get_uuid(name = "Sciurus vulgaris"),
      x = 0.1,
      y = 0.42, 
      height = 0.06
      )

ggsave("./figures/top_model_neg_binom_harvest.png", dpi=400, width = 6, height = 4)
```



## 5.7. Plot conditional effects for a fixed effect of interest **with** an interaction

```{r}
ggeffects::ggpredict(top_model, 
                              terms = c("veg_anthro_ed [all]", 
                                        paste0("harvest [",
                                               quantile(data_final_scaled$harvest, 0.80),
                                               ", ",
                                               quantile(data_final_scaled$harvest, 0.20),
                                               "]"))) %>%
                                                                          
  ggplot(., aes(x = x, y = predicted, color = group)) +
  
    geom_line(size = 0.5) +  # Set lines to black
    geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = group), alpha = 0.4, color = NA) +
  
    scale_color_manual(values = c('grey30', 'grey30'), labels = c("20% quantile", "80% quantile")) +  # Keep all lines black
  
    scale_fill_manual(values = c('dodgerblue4', 'orange3'), labels = c("20% quantile", "80% quantile")) +  # Set colors for ribbons
  
    labs(x = "Anthropogenic Edge Density", 
         y = "expected count",
         color = "harvest amount", fill = "harvest amount") +
  
    scale_x_continuous(expand = c(0, 0)) +  # Remove left blank space
  
    theme_bw() + 
  
    theme(panel.grid = element_blank()) + 
  
    add_phylopic(
      uuid = get_uuid(name = "Sciurus vulgaris"),
      x = 4.0,
      y = 0.45, 
      height = 0.1
      )
  
ggsave("./figures/top_model_harvest_edge_interaction.png", dpi=400, width = 7, height = 4)
```

