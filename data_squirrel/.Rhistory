# remove CL and WF arrays
dets <- dets %>%
filter(array != CL) %>%
filter(array != WF)
library(dplyr)
# we just need red squirrel detections
dets <- dets %>%
select(array,
site,
red_squirrel,
absent_red_squirrel)
dets <- read_csv("all_arrays_proportional_presence_weekly_clean.csv")
library(PerformanceAnalytics)
library(tidyverse)
library(MuMIn)
library(dplyr)
dets <- read_csv("all_arrays_proportional_presence_weekly_clean.csv")
setwd("~/GitHub/OSM_red_squirrel_distribution/data_squirrel")
dets <- read_csv("all_arrays_proportional_presence_weekly_clean.csv")
# we just need red squirrel detections
dets <- dets %>%
select(array,
site,
red_squirrel,
absent_red_squirrel)
# remove CL and WF arrays
dets <- dets %>%
filter(array != CL) %>%
filter(array != WF)
# remove CL and WF arrays
dets <- dets %>%
filter(array != "CL") %>%
filter(array != "WF")
View(dets)
str(dets)
summary(dets)
levels(array)
dets$array <- as.factor(dets$array)
levels(dets$array)
# covariate data
covs <- read_csv("OSM_covariates_grouped_2021_2022.csv")
str(covs)
summary(covs)
# need to drop the leading zeros in the site numbers so it can be combined with week data
covs <- covs %>%
mutate(
site = gsub("-", "_", site) %>% # First, replace the hyphen with underscore
gsub("_0+", "_", .) %>% # Then, remove leading zeros after the underscore
gsub(" ", "", .) %>% # Then, remove any spaces
gsub("LU0", "LU", .)) # Remove leading zeros from LU names for consistency
covs <- covs %>%
select(site, buff_dist, harvest, pipeline, roads, seismic_lines,
seismic_lines_3D, transmission_lines, veg_edges, wells,
lc_grassland, lc_coniferous,
lc_broadleaf, lc_mixed, lc_shrub, osm_industrial)
# group some variables
covs$seismic <- covs$seismic_lines + covs$seismic_lines_3D
covs$linear <- covs$transmission_lines + covs$pipeline
# drop the columns we don't need
covs <- covs %>%
select(-pipeline, -transmission_lines, -seismic_lines, -seismic_lines_3D)
buffer_frames <- list()
for (i in unique(covs$buff_dist)){
print(i)
# Subset data based on radius
df <- covs %>%
filter(buff_dist == i)
# list of dataframes
buffer_frames <- c(buffer_frames, list(df))
}
# name list objects so we can extract names for plotting
buffer_frames <- buffer_frames %>%
# absurdly long way to do this but for sake of time fuck it
purrr::set_names('250 meter buffer',
'500 meter buffer',
'750 meter buffer',
'1000 meter buffer',
'1250 meter buffer',
'1500 meter buffer',
'1750 meter buffer',
'2000 meter buffer',
'2250 meter buffer',
'2500 meter buffer',
'2750 meter buffer',
'3000 meter buffer',
'3250 meter buffer',
'3500 meter buffer',
'3750 meter buffer',
'4000 meter buffer',
'4250 meter buffer',
'4500 meter buffer',
'4750 meter buffer',
'5000 meter buffer')
squirrel <- buffer_frames %>%
purrr::map(
~.x %>%
left_join(dets,
by = 'site') %>%
select(array, everything()))
squirrel_mods <- squirrel %>%
purrr::map(
~ {
# get the buffer values (for model names)
buff_dist_value <- unique(.x$buff_dist)
# Pass squirrel to df and exclude site and buff_dist
df <- .x %>%
select(-site, -buff_dist)
# Treat array as a factor
df$array <- as.factor(df$array)
# these column are for the predictors
numeric_columns <- df %>%
# they should already be numeric
select(where(is.numeric)) %>%
# make sure the response is not included!
select(- red_squirrel, - absent_red_squirrel) %>%
names()
# List to store models
model_list <- purrr::map(numeric_columns, ~ {
# Create model formula
formula <- as.formula(paste("cbind(red_squirrel, absent_red_squirrel) ~",
.x, "+ (1 | array)"))
# model name using the variable and the buffer size
model_name <- paste0(.x, "_", buff_dist_value)
# Run the glmmTMB model for each numeric variable
model <- glmmTMB::glmmTMB(
formula = formula,
data = df,
family = 'binomial'
)
# Add the model name as a list element
model_with_name <- list(model = model, model_name = model_name)
return(model_with_name)
})
return(model_list)
})
# Extract model names from squirrel_mods
model_names <- purrr::map(squirrel_mods, ~ purrr::map(.x, "model_name"))
# Flatten the list to get a simple vector of names
model_names <- unlist(model_names)
model_info_df <- purrr::map_dfr(squirrel_mods, ~ {
purrr::map_dfr(.x, ~ {
model <- .x$model
model_name <- .x$model_name
# Extract the model's AIC, BIC, and logLik
model_summary <- data.frame(
model_name = model_name,
AIC = AIC(model),
logLik = logLik(model),
stringsAsFactors = FALSE
)
return(model_summary)
})  #
# remove lc because that is causing issues
model_info_df <- model_info_df %>%
mutate(model_name = str_remove(model_name, "^lc_"))
# new dataframe for each variable models
# Create dynamic data frames for each unique prefix in model_name
unique_prefixes <- unique(str_extract(model_info_df$model_name, "^[^_]+"))
# Create a list to store data frames
model_dataframes <- list()
# Loop over each prefix and create a corresponding data frame
for (prefix in unique_prefixes) {
model_dataframes[[prefix]] <- model_info_df %>%
filter(str_starts(model_name, prefix))
}
# separate dataframs
# Loop through the list and create separate data frames
for (name in names(model_dataframes)) {
assign(name, model_dataframes[[name]])
}
# all in one
# Extract the row with the highest AIC (or any other column you prefer)
top_model <- model_dataframes %>%
map(~ .x[which.min(.x$AIC), ]) %>%  # Extract the row with the highest AIC from each data frame
bind_rows()  # Combine the rows into a single data frame
model_info_df <- purrr::map_dfr(squirrel_mods, ~ {
purrr::map_dfr(.x, ~ {
model <- .x$model
model_name <- .x$model_name
# Extract the model's AIC, BIC, and logLik
model_summary <- data.frame(
model_name = model_name,
AIC = AIC(model),
logLik = logLik(model),
stringsAsFactors = FALSE
)
return(model_summary)
})  #
l
